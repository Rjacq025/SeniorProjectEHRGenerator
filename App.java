import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.TimeZone;
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;

import org.mitre.synthea.engine.Generator;
import org.mitre.synthea.engine.Module;
import org.mitre.synthea.export.Exporter;
import org.mitre.synthea.export.flexporter.Mapping;
import org.mitre.synthea.helpers.Config;
import org.mitre.synthea.helpers.Utilities;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

  /**
   * Display usage info - what are the command line args, examples, etc.
   */
  public static void usage() {
    System.out.println("Usage: run_synthea [options] [state [city]]");
    System.out.println("Options: [-s seed] [-cs clinicianSeed] [-p populationSize]");
    System.out.println("         [-ps singlePersonSeed]");
    System.out.println("         [-r referenceDate as YYYYMMDD]");
    System.out.println("         [-e endDate as YYYYMMDD]");
    System.out.println("         [-g gender] [-a minAge-maxAge]");
    System.out.println("         [-o overflowPopulation]");
    System.out.println("         [-c localConfigFilePath]");
    System.out.println("         [-d localModulesDirPath]");
    System.out.println("         [-i initialPopulationSnapshotPath]");
    System.out.println("         [-u updatedPopulationSnapshotPath]");
    System.out.println("         [-t updateTimePeriodInDays]");
    System.out.println("         [-f fixedRecordPath]");
    System.out.println("         [-k keepMatchingPatientsPath]");
    System.out.println("         [--config*=value]");
    System.out.println("          * any setting from src/main/resources/synthea.properties");
    System.out.println("Examples:");
    System.out.println("run_synthea Massachusetts");
    System.out.println("run_synthea Alaska Juneau");
    System.out.println("run_synthea -s 12345");
    System.out.println("run_synthea -p 1000");
    System.out.println("run_synthea -s 987 Washington Seattle");
    System.out.println("run_synthea -s 21 -p 100 Utah \"Salt Lake City\"");
    System.out.println("run_synthea -g M -a 60-65");
    System.out.println("run_synthea -p 10 --exporter.fhir.export=true");
    System.out.println("run_synthea --exporter.baseDirectory=\"./output_tx/\" Texas");
  }

  /**
   * Run Synthea generation.
   * @param args None. See documentation on configuration.
   * @throws Exception On errors.
   */
  public static void main(String[] args) throws Exception {

    //This prompts the user to choose a number of patients they want generated
    boolean hasPopulationArg = false;
    for (String arg : args) {
      if (arg.equalsIgnoreCase("-p")) {
        hasPopulationArg = true;
        break;
      }
    }

    Scanner scanner = new Scanner(System.in);

    if (!hasPopulationArg) {
      System.out.print("How many patients would you like to generate? ");
      String popSize = scanner.nextLine().trim();


      // Inject -p <popSize> into args
      String[] newArgs = new String[args.length + 2];
      System.arraycopy(args, 0, newArgs, 0, args.length);
      newArgs[args.length] = "-p";
      newArgs[args.length + 1] = popSize;

      args = newArgs;
    }

    //This code prompts the user to choose a state they want their data from
    String[] states = {
            "Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut",
            "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa",
            "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts", "Michigan",
            "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "New Hampshire",
            "New Jersey", "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio",
            "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina", "South Dakota",
            "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "West Virginia",
            "Wisconsin", "Wyoming"
    };

    System.out.println("\nSelect a state by entering the corresponding number:");
    for (int i = 0; i < states.length; i++) {
      System.out.printf("%2d. %s%n", i + 1, states[i]);
    }

    int stateChoice = -1;
    while (stateChoice < 1 || stateChoice > states.length) {
      System.out.print("Enter number (1-" + states.length + "): ");
      try {
        stateChoice = Integer.parseInt(scanner.nextLine());
      } catch (NumberFormatException e) {
        System.out.println("Invalid input. Please enter a number.");
      }
    }

    String selectedState = states[stateChoice - 1];
    System.out.println("Selected State: " + selectedState);

    List<String> argsList = new ArrayList<>(Arrays.asList(args));

    //This allows the user to choose male, female, or both
    System.out.println("Choose gender:");
    System.out.println("1. Male");
    System.out.println("2. Female");
    System.out.println("3. Both");

    String genderInput = scanner.nextLine().trim();
    switch (genderInput) {
      case "1":
        argsList.add("-g");
        argsList.add("M");
        System.out.println("Selected Gender: Male");
        break;
      case "2":
        argsList.add("-g");
        argsList.add("F");
        System.out.println("Selected Gender: Female");
        break;
      case "3":
        // Don't add -g, use default behavior (both)
        System.out.println("Selected Gender: Both");
        break;
      default:
        System.out.println("Invalid input. Proceeding with both genders.");
        break;
    }

    // This asks the user for checking whether or not they would like to set up an age range or not
    System.out.println("Would you like to filter by age range?");
    System.out.println("1. Yes");
    System.out.println("2. No (Include all ages)");

    String ageFilterInput = scanner.nextLine().trim();
    if (ageFilterInput.equals("1")) {
      System.out.print("Enter minimum age: ");
      String minAgeInput = scanner.nextLine().trim();

      System.out.print("Enter maximum age: ");
      String maxAgeInput = scanner.nextLine().trim();

      try {
        int minAge = Integer.parseInt(minAgeInput);
        int maxAge = Integer.parseInt(maxAgeInput);
        if (minAge <= maxAge) {
          argsList.add("-a");
          argsList.add(minAge + "-" + maxAge);
          System.out.println("Selected Age Range: " + minAge + "-" + maxAge);
        } else {
          System.out.println("Invalid range. Skipping age filter.");
        }
      } catch (NumberFormatException e) {
        System.out.println("Invalid input. Skipping age filter.");
      }
    } else {
      System.out.println("No age filtering applied.");
    }

    // Inject state into args
    String[] updatedArgs = new String[args.length + 1];
    System.arraycopy(args, 0, updatedArgs, 0, args.length);
    updatedArgs[args.length] = selectedState;
    argsList.add(selectedState);
    args = argsList.toArray(new String[0]);

    //Prompt export option Method Call
    promptExportSettings(scanner);

    //Close scanner
    scanner.close();

    Generator.GeneratorOptions options = new Generator.GeneratorOptions();
    Exporter.ExporterRuntimeOptions exportOptions = new Exporter.ExporterRuntimeOptions();

    boolean validArgs = true;
    boolean overrideFutureDateError = false;
    boolean reloadConfig = false;
    if (args != null && args.length > 0) {
      try {
        Queue<String> argsQ = new LinkedList<String>(Arrays.asList(args));

        while (!argsQ.isEmpty()) {
          String currArg = argsQ.poll();

          if (currArg.equalsIgnoreCase("-h")) {
            usage();
            System.exit(0);
          } else if (currArg.equalsIgnoreCase("-s")) {
            String value = argsQ.poll();
            options.seed = Long.parseLong(value);
          } else if (currArg.equalsIgnoreCase("-cs")) {
            String value = argsQ.poll();
            options.clinicianSeed = Long.parseLong(value);
          } else if (currArg.equalsIgnoreCase("-ps")) {
            String value = argsQ.poll();
            options.singlePersonSeed = Long.valueOf(value);
          } else if (currArg.equalsIgnoreCase("-r")) {
            String value = argsQ.poll();
            // note that Y = "week year" and y = "year" per the formatting guidelines
            // and D = "day in year" and d = "day in month", so what we actually want is yyyyMMdd
            // see: https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html
            SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");
            format.setTimeZone(TimeZone.getTimeZone("UTC"));
            options.referenceTime = format.parse(value).getTime();
          } else if (currArg.equalsIgnoreCase("-e")) {
            if (currArg.equals("-E")) {
              overrideFutureDateError = true;
            }
            String value = argsQ.poll();
            SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");
            format.setTimeZone(TimeZone.getTimeZone("UTC"));
            options.endTime = format.parse(value).getTime();
          } else if (currArg.equalsIgnoreCase("-p")) {
            String value = argsQ.poll();
            options.population = Integer.parseInt(value);
            Config.set("generate.default_population", value);
          } else if (currArg.equalsIgnoreCase("-o")) {
            String value = argsQ.poll();
            options.overflow = Boolean.parseBoolean(value);
          } else if (currArg.equalsIgnoreCase("-g")) {
            String value = argsQ.poll();
            if (value.equals("M") || value.equals("F")) {
              options.gender = value;
            } else {
              throw new Exception("Legal values for gender are 'M' or 'F'.");
            }
          } else if (currArg.equalsIgnoreCase("-a")) {
            String value = argsQ.poll();
            if (value.contains("-")) {
              String[] values = value.split("-");
              options.ageSpecified = true;
              options.minAge = Integer.parseInt(values[0]);
              options.maxAge = Integer.parseInt(values[1]);
            } else {
              throw new Exception("Age format: minAge-maxAge. E.g. 60-65.");
            }
          } else if (currArg.equalsIgnoreCase("-m")) {
            String value = argsQ.poll();
            String[] values = value.split(File.pathSeparator);
            options.enabledModules = Arrays.asList(values);
          } else if (currArg.equalsIgnoreCase("-c")) {
            String value = argsQ.poll();
            File configFile = new File(value);
            Config.load(configFile);
            reloadConfig = true;
          } else if (currArg.equalsIgnoreCase("-d")) {
            String value = argsQ.poll();
            File localModuleDir = new File(value);
            if (localModuleDir.exists() && localModuleDir.isDirectory()) {
              Module.addModules(localModuleDir);
            } else {
              throw new FileNotFoundException(String.format(
                      "Specified local module directory (%s) is not a directory",
                      localModuleDir.getAbsolutePath()));
            }
          } else if (currArg.equalsIgnoreCase("-u")) {
            String value = argsQ.poll();
            failIfPhysiologyEnabled(currArg);
            File file = new File(value);
            try {
              if (file.createNewFile()) {
                options.updatedPopulationSnapshotPath = file;
              } else {
                throw new IOException("File exists");
              }
            } catch (IOException ex) {
              throw new IOException(String.format("Unable to create snapshot file (%s): %s",
                      file.getAbsolutePath(), ex.getMessage()));
            }
          } else if (currArg.equalsIgnoreCase("-i")) {
            String value = argsQ.poll();
            failIfPhysiologyEnabled(currArg);
            File file = new File(value);
            try {
              if (file.exists() && file.canRead()) {
                options.initialPopulationSnapshotPath = file;
              } else {
                throw new IOException("File does not exist or is not readable");
              }
            } catch (IOException ex) {
              throw new IOException(String.format("Unable to load snapshot file (%s): %s",
                      file.getAbsolutePath(), ex.getMessage()));
            }
          } else if (currArg.startsWith("-t")) {
            String value = argsQ.poll();
            try {
              options.daysToTravelForward = Integer.parseInt(value);
              if (options.daysToTravelForward < 1) {
                throw new NumberFormatException("Must be a positive, non-zero integer");
              }
            } catch (NumberFormatException ex) {
              throw new IllegalArgumentException(
                      String.format(
                              "Error in specified updateTimePeriodInDays (%s): %s",
                              value,
                              ex.getMessage()));
            }
          } else if (currArg.equalsIgnoreCase("-f")) {
            String value = argsQ.poll();
            File fixedRecordPath = new File(value);
            if (fixedRecordPath.exists()) {
              options.fixedRecordPath = fixedRecordPath;
            } else {
              throw new FileNotFoundException(String.format(
                  "Specified fixed record file (%s) does not exist", value));
            }
          } else if (currArg.equals("-k")) {
            String value = argsQ.poll();
            // first check if it's an absolute path, or path relative to .
            File keepPatientsModule = new File(value);
            if (keepPatientsModule.exists()) {
              options.keepPatientsModulePath = keepPatientsModule.toPath();
            } else {
              // look inside the src/main/resources/keep_modules folder
              URI keepModulesURI = App.class.getClassLoader().getResource("keep_modules").toURI();
              Utilities.enableReadingURIFromJar(keepModulesURI);
              Path possibleLocation = Paths.get(keepModulesURI).resolve(value);
              if (Files.exists(possibleLocation)) {
                options.keepPatientsModulePath = possibleLocation;
              } else {
                throw new FileNotFoundException(String.format(
                    "Specified keep-patients file (%s) does not exist", value));
              }
            }
          } else if (currArg.equals("-fm")) {
            String value = argsQ.poll();
            File flexporterMappingFile = new File(value);
            if (flexporterMappingFile.exists()) {
              Mapping mapping = Mapping.parseMapping(flexporterMappingFile);
              exportOptions.addFlexporterMapping(mapping);
              mapping.loadValueSets();

              // disable the graalVM warning when FlexporterJavascriptContext is instantiated
              System.getProperties().setProperty("polyglot.engine.WarnInterpreterOnly", "false");
            } else {
              throw new FileNotFoundException(String.format(
                  "Specified flexporter mapping file (%s) does not exist", value));
            }
          } else if (currArg.equals("-ig")) {
            String value = argsQ.poll();
            File igFile = new File(value);
            if (igFile.exists()) {
              RunFlexporter.loadIG(igFile);
            } else {
              throw new FileNotFoundException(String.format(
                  "Specified IG directory (%s) does not exist", value));
            }
          } else if (currArg.startsWith("--")) {
            String configSetting;
            String value;
            // accept either:
            // --config.setting=value
            // --config.setting value
            if (currArg.contains("=")) {
              String[] parts = currArg.split("=", 2);
              configSetting = parts[0].substring(2);
              value = parts[1];
            } else {
              configSetting = currArg.substring(2);
              value = argsQ.poll();
            }

            Config.set(configSetting, value);
            reloadConfig = true;
          } else if (options.state == null) {
            options.state = currArg;
          } else {
            // assume it must be the city
            options.city = currArg;
          }
        }
      } catch (Exception e) {
        e.printStackTrace();
        usage();
        validArgs = false;
      }
    }

    if (reloadConfig) {
      resetOptionsFromConfig(options, exportOptions);
    }

    if (validArgs && validateConfig(options, overrideFutureDateError)) {
      Generator generator = new Generator(options, exportOptions);
      generator.run();
    }
  }

  private static void promptExportSettings(Scanner scanner) {
    System.out.println("Would you like to export the generated patients? (yes/no)");
    String exportChoice = scanner.nextLine().trim().toLowerCase();

    if (exportChoice.equals("yes")) {
      System.out.println("Select export format:");
      System.out.println("1. All (CSV, FHIR, CCDA)");
      System.out.println("2. CSV only");
      System.out.println("3. FHIR only");
      System.out.println("4. CCDA only");
      String formatInput = scanner.nextLine().trim();

      // Disable all exporters by default
      Config.set("exporter.csv.export", "false");
      Config.set("exporter.fhir.export", "false");
      Config.set("exporter.ccda.export", "false");

      switch (formatInput) {
        case "2":
          Config.set("exporter.csv.export", "true");
          System.out.println("Export Format Selected: CSV");
          break;
        case "3":
          Config.set("exporter.fhir.export", "true");
          System.out.println("Export Format Selected: FHIR");
          break;
        case "4":
          Config.set("exporter.ccda.export", "true");
          System.out.println("Export Format Selected: CCDA");
          break;
        default:
          Config.set("exporter.csv.export", "true");
          Config.set("exporter.fhir.export", "true");
          Config.set("exporter.ccda.export", "true");
          System.out.println("Export Format Selected: All (CSV, FHIR, CCDA)");
          break;
      }

      // Ask for export path
      System.out.print("Enter output directory path (or press Enter for default './output'): ");
      String outputPath = scanner.nextLine().trim();
      if (!outputPath.isEmpty()) {
        Config.set("exporter.baseDirectory", outputPath);
        System.out.println("Export Directory: " + outputPath);
      } else {
        System.out.println("Using default export directory: ./output");
      }

    } else {
      System.out.println("Export skipped. No patient data will be written to disk.");
      // Disable all export types
      Config.set("exporter.csv.export", "false");
      Config.set("exporter.fhir.export", "false");
      Config.set("exporter.ccda.export", "false");
    }
  }



  /**
   * Reset the fields of the provided options to the current values in the Config.
   */
  private static void resetOptionsFromConfig(Generator.GeneratorOptions options,
      Exporter.ExporterRuntimeOptions exportOptions) {
    // Any options that are automatically set by reading the configuration
    // file during options initialization need to be reset here.
    options.population = Config.getAsInteger("generate.default_population", 1);
    options.threadPoolSize = Config.getAsInteger("generate.thread_pool_size", -1);

    exportOptions.yearsOfHistory = Config.getAsInteger("exporter.years_of_history", 10);
    exportOptions.terminologyService = !Config.get("generate.terminology_service_url", "")
            .isEmpty();
  }

  private static boolean validateConfig(Generator.GeneratorOptions options,
          boolean overrideFutureDateError) {
    boolean valid = true;
    if (Config.getAsBoolean("exporter.fhir.transaction_bundle")
            && ! Config.getAsBoolean("exporter.practitioner.fhir.export")
            && ! Config.getAsBoolean("exporter.hospital.fhir.export")) {
      System.out.println("Warning: Synthea is configured to export FHIR transaction bundles "
              + "for generated patients but not to export the practitioners and organizations "
              + "that the patient bundle entries will reference. "
              + "See https://github.com/synthetichealth/synthea/wiki/FHIR-Transaction-Bundles "
              + "for more information."
      );
    }
    if (!overrideFutureDateError) {
      int yearsOfHistory = Config.getAsInteger("exporter.years_of_history");
      long millisToEndTime = options.endTime - System.currentTimeMillis();
      if (millisToEndTime > Utilities.convertTime("years", yearsOfHistory)) {
        System.out.println("Error: the specified end time is further in the future than the "
                + "number of years of export history. The first exported events will be in the "
                + "future. Consider adjusting the values of the '-e endDate' command line switch "
                + "and the 'exporter.years_of_history' configuration file entry.\n"
                + "You may override this error by using '-E endDate' instead of '-e EndDate'."
        );
        valid = false;
      }
    }
    return valid;
  }

  private static void failIfPhysiologyEnabled(String arg) {
    if (Boolean.valueOf(Config.get("physiology.generators.enabled", "false"))) {
      String errString = String.format(
              "The %s command line switch %s - %s",
              arg,
              "cannot be used when physiology generators are enabled",
              "set configuration option physiology.generators.enabled=false to use"
      );
      throw new IllegalArgumentException(errString);
    }
  }
}
